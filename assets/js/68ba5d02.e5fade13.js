"use strict";(self.webpackChunkdanieltjw_pf=self.webpackChunkdanieltjw_pf||[]).push([[4415],{8109:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>d,contentTitle:()=>o,default:()=>c,frontMatter:()=>l,metadata:()=>i,toc:()=>a});const i=JSON.parse('{"id":"Interview_Preperation/Python_Algorithms_Notes","title":"Python Notes on Algorithms","description":"Breadth-First Search (BFS)","source":"@site/docs/Interview_Preperation/Python_Algorithms_Notes.md","sourceDirName":"Interview_Preperation","slug":"/Interview_Preperation/Python_Algorithms_Notes","permalink":"/danieltjw-pf/docs/Interview_Preperation/Python_Algorithms_Notes","draft":false,"unlisted":false,"editUrl":"https://github.com/Danieltanjw/danieltjw-pf/docs/Interview_Preperation/Python_Algorithms_Notes.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Leetcode Notes","permalink":"/danieltjw-pf/docs/Interview_Preperation/"},"next":{"title":"LeetCode Notes","permalink":"/danieltjw-pf/docs/Interview_Preperation/Things_To_Remember"}}');var s=r(4848),t=r(8453);const l={},o="Python Notes on Algorithms",d={},a=[{value:"Breadth-First Search (BFS)",id:"breadth-first-search-bfs",level:2},{value:"Depth-First Search (DFS)",id:"depth-first-search-dfs",level:2},{value:"Binary Search",id:"binary-search",level:2},{value:"Sorting Algorithms",id:"sorting-algorithms",level:2},{value:"Bubble Sort",id:"bubble-sort",level:3},{value:"Insertion Sort",id:"insertion-sort",level:3},{value:"Radix Sort",id:"radix-sort",level:3},{value:"Counting Sort",id:"counting-sort",level:3},{value:"Bucket Sort",id:"bucket-sort",level:3},{value:"Tree Traversals",id:"tree-traversals",level:2},{value:"Preorder",id:"preorder",level:3},{value:"Inorder",id:"inorder",level:3},{value:"Postorder",id:"postorder",level:3},{value:"Two Pointer Technique",id:"two-pointer-technique",level:2},{value:"Slow-Fast Pointer",id:"slow-fast-pointer",level:2},{value:"Greedy Algorithm",id:"greedy-algorithm",level:2},{value:"Dijkstra&#39;s Algorithm",id:"dijkstras-algorithm",level:2},{value:"Floyd-Warshall Algorithm",id:"floyd-warshall-algorithm",level:2},{value:"Bellman-Ford Algorithm",id:"bellman-ford-algorithm",level:2},{value:"Kruskal&#39;s Algorithm",id:"kruskals-algorithm",level:2},{value:"Prim&#39;s Algorithm",id:"prims-algorithm",level:2},{value:"Topological Sorting",id:"topological-sorting",level:2},{value:"Floyd&#39;s Cycle Detection Algorithm",id:"floyds-cycle-detection-algorithm",level:2},{value:"Sorting Algorithms",id:"sorting-algorithms-1",level:2},{value:"Quick Sort",id:"quick-sort",level:3},{value:"Merge Sort",id:"merge-sort",level:3},{value:"Heap Sort",id:"heap-sort",level:3},{value:"Sliding Window Technique",id:"sliding-window-technique",level:2},{value:"Backtracking",id:"backtracking",level:2},{value:"Kadane&#39;s Algorithm",id:"kadanes-algorithm",level:2},{value:"Longest Increasing Subsequence (LIS)",id:"longest-increasing-subsequence-lis",level:2}];function h(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(e.header,{children:(0,s.jsx)(e.h1,{id:"python-notes-on-algorithms",children:"Python Notes on Algorithms"})}),"\n",(0,s.jsx)(e.h2,{id:"breadth-first-search-bfs",children:"Breadth-First Search (BFS)"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": A graph traversal technique where you explore all the neighbors at the current depth before moving on to nodes at the next depth level."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Cases"}),": Shortest path in unweighted graphs, level-order traversal in trees."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":\nTime: O(V+E) where V is the number of vertices and E is the number of edges.\nSpace: O(V) due to the queue."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Use a queue to keep track of nodes to visit."}),"\n",(0,s.jsx)(e.li,{children:"Start with the root node and mark it as visited."}),"\n",(0,s.jsx)(e.li,{children:"Explore each node's unvisited neighbors and enqueue them."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'from collections import deque\n\ndef bfs(graph, start):\n    visited = set()\n    queue = deque([start])\n    while queue:\n        node = queue.popleft()\n        if node not in visited:\n            visited.add(node)\n            print(node, end=" ")\n            queue.extend(neighbor for neighbor in graph[node] if neighbor not in visited)\n'})}),"\n",(0,s.jsx)(e.h2,{id:"depth-first-search-dfs",children:"Depth-First Search (DFS)"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": A graph traversal method where you explore as far as possible along each branch before backtracking."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Cases"}),": Detecting cycles, connected components, and topological sorting."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":\nTime: O(V+E)\nSpace: O(V) in the worst case for recursions stack."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Use a stack (or recursion) to explore nodes."}),"\n",(0,s.jsx)(e.li,{children:"Mark nodes as visited once encountered."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def dfs(graph, start, visited=None):\n    if visited is None:\n        visited = set()\n    visited.add(start)\n    print(start, end=" ")\n    for neighbor in graph[start]:\n        if neighbor not in visited:\n            dfs(graph, neighbor, visited)\n'})}),"\n",(0,s.jsx)(e.h2,{id:"binary-search",children:"Binary Search"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": A search algorithm that finds the position of a target value within a sorted array."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Cases"}),": Searching in sort datasets, finding elements, lower/upper bounds."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":\nTime: O(logn)\nSpace: O(1)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Divide the array into two halves."}),"\n",(0,s.jsx)(e.li,{children:"Compare the target with the middle element."}),"\n",(0,s.jsx)(e.li,{children:"Repeat for the left or right half based on comparison."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def binary_search(arr, target):\n    left, right = 0, len(arr) - 1\n    while left <= right:\n        mid = (left + right) // 2\n        if arr[mid] == target:\n            return mid\n        elif arr[mid] < target:\n            left = mid + 1\n        else:\n            right = mid - 1\n    return -1\n"})}),"\n",(0,s.jsx)(e.h2,{id:"sorting-algorithms",children:"Sorting Algorithms"}),"\n",(0,s.jsx)(e.h3,{id:"bubble-sort",children:"Bubble Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Repeatedly swap adjacent elements if they are in the wrong order."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":\nTime: O(n^2) in the worst case\nSpace: O(1) in-place"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def bubble_sort(arr):\n    n = len(arr)\n    for i in range(n):\n        for j in range(0, n-i-1):\n            if arr[j] > arr[j+1]:\n                arr[j], arr[j+1] = arr[j+1], arr[j]\n"})}),"\n",(0,s.jsx)(e.h3,{id:"insertion-sort",children:"Insertion Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Build the sorted array one element at a time by comparing and inserting elements."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":\nTime: O(n^2) in the worst case\nSpace: O(1) in-place"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def insertion_sort(arr):\n    for i in range(1, len(arr)):\n        key = arr[i]\n        j = i - 1\n        while j >= 0 and key < arr[j]:\n            arr[j + 1] = arr[j]\n            j -= 1\n        arr[j + 1] = key\n"})}),"\n",(0,s.jsx)(e.h3,{id:"radix-sort",children:"Radix Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Non-comparative sorting algorithm that sorts by processing individual digits."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":\nTime: O(d(n+b)), where d is the number of digits, n is the number of elements, and b is the base.\nSpace: O(n+b)"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def counting_sort_for_radix(arr, exp):\n    n = len(arr)\n    output = [0] * n\n    count = [0] * 10\n\n    for i in arr:\n        index = (i // exp) % 10\n        count[index] += 1\n\n    for i in range(1, 10):\n        count[i] += count[i - 1]\n\n    i = n - 1\n    while i >= 0:\n        index = (arr[i] // exp) % 10\n        output[count[index] - 1] = arr[i]\n        count[index] -= 1\n        i -= 1\n\n    for i in range(len(arr)):\n        arr[i] = output[i]\n\ndef radix_sort(arr):\n    max_num = max(arr)\n    exp = 1\n    while max_num // exp > 0:\n        counting_sort_for_radix(arr, exp)\n        exp *= 10\n"})}),"\n",(0,s.jsx)(e.h3,{id:"counting-sort",children:"Counting Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Non-comparative sorting algorithm that counts the frequency of each element."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def counting_sort(arr):\n    max_val = max(arr)\n    count = [0] * (max_val + 1)\n    for num in arr:\n        count[num] += 1\n    index = 0\n    for i, freq in enumerate(count):\n        for _ in range(freq):\n            arr[index] = i\n            index += 1\n"})}),"\n",(0,s.jsx)(e.h3,{id:"bucket-sort",children:"Bucket Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Distributes elements into buckets and sorts each bucket individually."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def bucket_sort(arr):\n    max_val = max(arr)\n    size = max_val / len(arr)\n    buckets = [[] for _ in range(len(arr))]\n\n    for i in range(len(arr)):\n        index = int(arr[i] / size)\n        if index != len(arr):\n            buckets[index].append(arr[i])\n        else:\n            buckets[len(arr) - 1].append(arr[i])\n\n    for bucket in buckets:\n        bucket.sort()\n\n    result = []\n    for bucket in buckets:\n        result.extend(bucket)\n    return result\n"})}),"\n",(0,s.jsx)(e.h2,{id:"tree-traversals",children:"Tree Traversals"}),"\n",(0,s.jsx)(e.h3,{id:"preorder",children:"Preorder"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Visit root, left, right."}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Case"}),": Copying trees, prefix expressions."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def preorder(root):\n    if root:\n        print(root.val, end=" ")\n        preorder(root.left)\n        preorder(root.right)\n'})}),"\n",(0,s.jsx)(e.h3,{id:"inorder",children:"Inorder"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Visit left, root, right."}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Case"}),": Sorting elements in a binary search tree."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def inorder(root):\n    if root:\n        inorder(root.left)\n        print(root.val, end=" ")\n        inorder(root.right)\n'})}),"\n",(0,s.jsx)(e.h3,{id:"postorder",children:"Postorder"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Visit left, right, root."}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Use Case"}),": Deleting or freeing memory."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:'def postorder(root):\n    if root:\n        postorder(root.left)\n        postorder(root.right)\n        print(root.val, end=" ")\n'})}),"\n",(0,s.jsx)(e.h2,{id:"two-pointer-technique",children:"Two Pointer Technique"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Use two pointers to traverse an array or list to solve problems efficiently."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def two_sum(arr, target):\n    left, right = 0, len(arr) - 1\n    while left < right:\n        curr_sum = arr[left] + arr[right]\n        if curr_sum == target:\n            return left, right\n        elif curr_sum < target:\n            left += 1\n        else:\n            right -= 1\n"})}),"\n",(0,s.jsx)(e.h2,{id:"slow-fast-pointer",children:"Slow-Fast Pointer"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Use two pointers moving at different speeds to detect cycles."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def has_cycle(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n"})}),"\n",(0,s.jsx)(e.h2,{id:"greedy-algorithm",children:"Greedy Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Build up a solution piece by piece, always choosing the next piece that offers the most immediate benefit."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def coin_change(coins, amount):\n    coins.sort(reverse=True)\n    count = 0\n    for coin in coins:\n        if amount == 0:\n            break\n        count += amount // coin\n        amount %= coin\n    return count if amount == 0 else -1\n"})}),"\n",(0,s.jsx)(e.h2,{id:"dijkstras-algorithm",children:"Dijkstra's Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Finds the shortest path from a source node to all other nodes in a graph with non-negative edge weights."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a priority queue to explore the closest unvisited node."}),"\n",(0,s.jsx)(e.li,{children:"Relax edges by updating distances if a shorter path is found."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Initialize distances to all nodes as infinity, except the source node (0)."}),"\n",(0,s.jsx)(e.li,{children:"Use a priority queue to process nodes with the smallest known distance."}),"\n",(0,s.jsx)(e.li,{children:"For the current node, update distances to its neighbors if a shorter path is found."}),"\n",(0,s.jsx)(e.li,{children:"Mark the current node as visited."}),"\n",(0,s.jsx)(e.li,{children:"Repeat until all nodes are processed or the priority queue is empty."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O((V + E) \\log V)) using a priority queue."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(V)) for the distance table and priority queue."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import heapq\n\ndef dijkstra(graph, start):\n    distances = {node: float('inf') for node in graph}\n    distances[start] = 0\n    priority_queue = [(0, start)]\n    \n    while priority_queue:\n        current_distance, current_node = heapq.heappop(priority_queue)\n        if current_distance > distances[current_node]:\n            continue\n        for neighbor, weight in graph[current_node].items():\n            distance = current_distance + weight\n            if distance < distances[neighbor]:\n                distances[neighbor] = distance\n                heapq.heappush(priority_queue, (distance, neighbor))\n    return distances\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"floyd-warshall-algorithm",children:"Floyd-Warshall Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": A dynamic programming algorithm to compute shortest paths between all pairs of nodes."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a distance matrix where (dist[i][j]) represents the shortest distance from node (i) to (j)."}),"\n",(0,s.jsx)(e.li,{children:"Update the matrix iteratively using each node as an intermediate node."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Initialize the distance matrix with edge weights and infinity for no direct edge."}),"\n",(0,s.jsx)(e.li,{children:"Set (dist[i][i] = 0) for all (i)."}),"\n",(0,s.jsx)(e.li,{children:"For each intermediate node (k), update (dist[i][j]) as:\n[\ndist[i][j] = \\min(dist[i][j], dist[i][k] + dist[k][j])\n]"}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O(V^3))."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(V^2))."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def floyd_warshall(graph):\n    nodes = list(graph.keys())\n    distance = {node: {n: float('inf') for n in nodes} for node in nodes}\n    \n    for node in nodes:\n        distance[node][node] = 0\n        for neighbor, weight in graph[node].items():\n            distance[node][neighbor] = weight\n    \n    for k in nodes:\n        for i in nodes:\n            for j in nodes:\n                distance[i][j] = min(distance[i][j], distance[i][k] + distance[k][j])\n    \n    return distance\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"bellman-ford-algorithm",children:"Bellman-Ford Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Finds shortest paths from a source node to all other nodes in a graph, even with negative edge weights."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Relax all edges (V-1) times, where (V) is the number of vertices."}),"\n",(0,s.jsx)(e.li,{children:"Check for negative weight cycles in an additional iteration."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Initialize distances to infinity, except for the source node (0)."}),"\n",(0,s.jsx)(e.li,{children:"For each vertex, relax all edges by updating distances if a shorter path is found."}),"\n",(0,s.jsx)(e.li,{children:"Perform one more relaxation to detect negative weight cycles."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O(V \\cdot E))."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(V)) for the distance table."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def bellman_ford(edges, vertices, start):\n    distances = {v: float('inf') for v in vertices}\n    distances[start] = 0\n    \n    for _ in range(len(vertices) - 1):\n        for u, v, weight in edges:\n            if distances[u] + weight < distances[v]:\n                distances[v] = distances[u] + weight\n    \n    # Check for negative weight cycles\n    for u, v, weight in edges:\n        if distances[u] + weight < distances[v]:\n            raise ValueError(\"Graph contains a negative weight cycle\")\n    \n    return distances\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"kruskals-algorithm",children:"Kruskal's Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Constructs the Minimum Spanning Tree (MST) by selecting edges in increasing order of weight."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a union-find data structure to avoid forming cycles."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Sort all edges by weight."}),"\n",(0,s.jsx)(e.li,{children:"Use the union-find algorithm to add edges to the MST without forming a cycle."}),"\n",(0,s.jsx)(e.li,{children:"Stop when the MST has (V-1) edges."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O(E \\log E)) for sorting edges."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(V))."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def kruskal(edges, num_vertices):\n    edges.sort(key=lambda x: x[2])  # Sort edges by weight\n    parent = list(range(num_vertices))\n    \n    def find(v):\n        if parent[v] != v:\n            parent[v] = find(parent[v])\n        return parent[v]\n    \n    def union(u, v):\n        root_u = find(u)\n        root_v = find(v)\n        if root_u != root_v:\n            parent[root_u] = root_v\n    \n    mst = []\n    for u, v, weight in edges:\n        if find(u) != find(v):\n            union(u, v)\n            mst.append((u, v, weight))\n    \n    return mst\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"prims-algorithm",children:"Prim's Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Constructs the MST by starting from a node and growing the tree."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a priority queue to select the smallest edge that connects a new node to the MST."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Start with an arbitrary node."}),"\n",(0,s.jsx)(e.li,{children:"Add the smallest edge connecting the MST to a new node."}),"\n",(0,s.jsx)(e.li,{children:"Repeat until all nodes are included."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O((V + E) \\log V))."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(V))."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"import heapq\n\ndef prim(graph, start):\n    mst = []\n    visited = set()\n    priority_queue = [(0, start, None)]  # (weight, node, parent)\n    \n    while priority_queue:\n        weight, node, parent = heapq.heappop(priority_queue)\n        if node not in visited:\n            visited.add(node)\n            if parent is not None:\n                mst.append((parent, node, weight))\n            \n            for neighbor, cost in graph[node].items():\n                if neighbor not in visited:\n                    heapq.heappush(priority_queue, (cost, neighbor, node))\n    \n    return mst\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"topological-sorting",children:"Topological Sorting"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": A linear ordering of vertices in a DAG such that for every directed edge (u \to v), (u) appears before (v)."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use DFS to order nodes by their finish times or Kahn\u2019s algorithm to process nodes with zero in-degrees."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsx)(e.li,{children:"Initialize a stack (DFS) or a queue (BFS)."}),"\n",(0,s.jsx)(e.li,{children:"Use DFS to visit nodes and push them to the stack in reverse order of finish."}),"\n",(0,s.jsx)(e.li,{children:"Alternatively, process nodes with zero in-degrees using BFS."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O(V + E))."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(V))."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def topological_sort(graph):\n    in_degree = {node: 0 for node in graph}\n    for node in graph:\n        for neighbor in graph[node]:\n            in_degree[neighbor] += 1\n    \n    queue = [node for node in graph if in_degree[node] == 0]\n    result = []\n    \n    while queue:\n        node = queue.pop(0)\n        result.append(node)\n        for neighbor in graph[node]:\n            in_degree[neighbor] -= 1\n            if in_degree[neighbor] == 0:\n                queue.append(neighbor)\n    \n    return result\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"floyds-cycle-detection-algorithm",children:"Floyd's Cycle Detection Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Detects cycles in a sequence using two pointers moving at different speeds."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"If there\u2019s a cycle, the slow and fast pointers will meet."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Steps"}),":","\n",(0,s.jsxs)(e.ol,{children:["\n",(0,s.jsxs)(e.li,{children:["Initialize ",(0,s.jsx)(e.code,{children:"slow"})," and ",(0,s.jsx)(e.code,{children:"fast"})," pointers at the start."]}),"\n",(0,s.jsxs)(e.li,{children:["Move ",(0,s.jsx)(e.code,{children:"slow"})," by one step and ",(0,s.jsx)(e.code,{children:"fast"})," by two steps."]}),"\n",(0,s.jsxs)(e.li,{children:["If ",(0,s.jsx)(e.code,{children:"slow == fast"}),", there\u2019s a cycle."]}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Time: (O(n))."}),"\n",(0,s.jsx)(e.li,{children:"Space: (O(1))."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def floyd_cycle_detection(head):\n    slow, fast = head, head\n    while fast and fast.next:\n        slow = slow.next\n        fast = fast.next.next\n        if slow == fast:\n            return True\n    return False\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"sorting-algorithms-1",children:"Sorting Algorithms"}),"\n",(0,s.jsx)(e.h3,{id:"quick-sort",children:"Quick Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": A divide-and-conquer algorithm that partitions the array and recursively sorts the partitions."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Choose a pivot and partition the array so that elements less than the pivot are on one side and greater on the other."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Average: (O(n \\log n))."}),"\n",(0,s.jsx)(e.li,{children:"Worst: (O(n^2))."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def quick_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    pivot = arr[len(arr) // 2]\n    left = [x for x in arr if x < pivot]\n    middle = [x for x in arr if x == pivot]\n    right = [x for x in arr if x > pivot]\n    return quick_sort(left) + middle + quick_sort(right)\n"})}),"\n",(0,s.jsx)(e.h3,{id:"merge-sort",children:"Merge Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Divides the array into halves, sorts them, and merges the sorted halves."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),": (O(n \\log n))."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def merge_sort(arr):\n    if len(arr) <= 1:\n        return arr\n    \n    mid = len(arr) // 2\n    left = merge_sort(arr[:mid])\n    right = merge_sort(arr[mid:])\n    \n    return merge(left, right)\n\ndef merge(left, right):\n    result = []\n    i = j = 0\n    \n    while i < len(left) and j < len(right):\n        if left[i] < right[j]:\n            result.append(left[i])\n            i += 1\n        else:\n            result.append(right[j])\n            j += 1\n    \n    result.extend(left[i:])\n    result.extend(right[j:])\n    return result\n"})}),"\n",(0,s.jsx)(e.h3,{id:"heap-sort",children:"Heap Sort"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Uses a binary heap to sort elements by repeatedly extracting the maximum/minimum."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),": (O(n \\log n))."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def heapify(arr, n, i):\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    if left < n and arr[left] > arr[largest]:\n        largest = left\n    if right < n and arr[right] > arr[largest]:\n        largest = right\n\n    if largest != i:\n        arr[i], arr[largest] = arr[largest], arr[i]\n        heapify(arr, n, largest)\n\ndef heap_sort(arr):\n    n = len(arr)\n\n    # Build max heap\n    for i in range(n // 2 - 1, -1, -1):\n        heapify(arr, n, i)\n\n    # Extract elements one by one\n    for i in range(n - 1, 0, -1):\n        arr[0], arr[i] = arr[i], arr[0]\n        heapify(arr, i, 0)\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"sliding-window-technique",children:"Sliding Window Technique"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Efficiently solves problems involving subarrays or substrings."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Key Idea"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"Use a fixed or dynamic window to maintain the required properties."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),": (O(n))."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def sliding_window_max(nums, k):\n    from collections import deque\n    result = []\n    dq = deque()\n    \n    for i in range(len(nums)):\n        while dq and dq[0] < i - k + 1:\n            dq.popleft()\n        while dq and nums[dq[-1]] < nums[i]:\n            dq.pop()\n        dq.append(i)\n        if i >= k - 1:\n            result.append(nums[dq[0]])\n    \n    return result\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"backtracking",children:"Backtracking"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Explores all possible solutions and backtracks upon encountering invalid solutions."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),": Typically exponential."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def solve_n_queens(n):\n    def is_safe(board, row, col):\n        for i in range(row):\n            if board[i] == col or abs(board[i] - col) == row - i:\n                return False\n        return True\n    \n    def solve(row):\n        if row == n:\n            result.append(board[:])\n            return\n        for col in range(n):\n            if is_safe(board, row, col):\n                board[row] = col\n                solve(row + 1)\n                board[row] = -1\n    \n    result = []\n    board = [-1] * n\n    solve(0)\n    return result\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"kadanes-algorithm",children:"Kadane's Algorithm"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Finds the maximum sum of a contiguous subarray in (O(n))."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def kadane(arr):\n    max_current = max_global = arr[0]\n    for num in arr[1:]:\n        max_current = max(num, max_current + num)\n        if max_current > max_global:\n            max_global = max_current\n    return max_global\n"})}),"\n",(0,s.jsx)(e.hr,{}),"\n",(0,s.jsx)(e.h2,{id:"longest-increasing-subsequence-lis",children:"Longest Increasing Subsequence (LIS)"}),"\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Definition"}),": Finds the length of the longest subsequence with increasing elements."]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Complexity"}),":","\n",(0,s.jsxs)(e.ul,{children:["\n",(0,s.jsx)(e.li,{children:"(O(n^2)) using dynamic programming."}),"\n",(0,s.jsx)(e.li,{children:"(O(n \\log n)) with binary search optimization."}),"\n"]}),"\n"]}),"\n",(0,s.jsxs)(e.li,{children:[(0,s.jsx)(e.strong,{children:"Example"}),":"]}),"\n"]}),"\n",(0,s.jsx)(e.pre,{children:(0,s.jsx)(e.code,{className:"language-python",children:"def lis(nums):\n    dp = []\n    for num in nums:\n        idx = bisect.bisect_left(dp, num)\n        if idx == len(dp):\n            dp.append(num)\n        else:\n            dp[idx] = num\n    return len(dp)\n"})})]})}function c(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,s.jsx)(e,{...n,children:(0,s.jsx)(h,{...n})}):h(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>l,x:()=>o});var i=r(6540);const s={},t=i.createContext(s);function l(n){const e=i.useContext(t);return i.useMemo((function(){return"function"==typeof n?n(e):{...e,...n}}),[e,n])}function o(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:l(n.components),i.createElement(t.Provider,{value:e},n.children)}}}]);